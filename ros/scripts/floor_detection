#!/usr/bin/env python
import yaml
import rospy
from std_msgs.msg import Int32
from ropod_ros_msgs.msg import SmartWheelData
from pyftsm.ftsm import FTSMStates, FTSMTransitions
from ropod.ftsm.ftsm_base import FTSMBase, DependMonitorTypes

from floor_detection.floor_detector import FloorDetector
from floor_detection.srv import DetectFloor, DetectFloorResponse

class FloorDetectionNode(FTSMBase):
    '''A ROS node exposing a floor detection functionality based on pressure
    sensor measurements from (potentially multiple) smart wheels. The detector
    uses the change in pressure measurements for detecting floor changes, so the
    starting floor should be initialised manually for the component to work properly.

    The detector uses the following configuration parameters:
    * a reference floor
    * number of redundant measurements
    * window size of the detector's median filter
    * expected pressure differences between floors expressed with respect to the reference floor
    * error tolerance for the pressure differences
    The configuration parameters are specified in a YAML file that has the following format:

    ---------------------------------------------------------------------------
    reference_floor: int
    floor_measurements:
    - floor_number: int
      mean_pressure_diff: float
    - floor_number: int
      mean_pressure_diff: float
    pressure_diff_tolerance: float
    redundant_measurement_count: int
    filter_window_size: int
    ---------------------------------------------------------------------------

    Note: The expected pressure differences need to be calibrated
    for a specific building and sensor.

    The node expects the following parameters to be made available to the ROS parameter server:
    config_file_path: str -- configuration file for the floor detector
    server_name: str -- name of the floor detection service exposed by the node
                        (default floor_detection_server)
    set_floor_topic: str -- name of a topic on which the floor can be set manually
                            (default /set_floor)
    sw_data_topic: str -- name of a topic on which smart wheel data are published
                          (default /sw_ethercat_parser/data)

    @author Alex Mitrevski
    @contact aleksandar.mitrevski@h-brs.de

    '''
    def __init__(self):
        component_name = 'floor_detector'
        dependencies = ['smart_wheel', 'pressure']
        dependency_monitors = {'heartbeat': {'smart_wheel': 'ros/ros_node_monitor'},
                               'functional': {'pressure': 'pressure/pressure_functional_monitor'}}
        super(FloorDetectionNode, self).__init__(component_name,
                                                 dependencies,
                                                 dependency_monitors)

        self.server_name = rospy.get_param('~detection_server_name', 'floor_detection_server')
        self.set_floor_topic = rospy.get_param('~set_floor_topic', '/set_floor')
        self.sw_data_topic = rospy.get_param('~sw_data_topic', '/sw_ethercat_parser/data')
        config_file_path = rospy.get_param('~config_file', '')

        self.reference_floor = 0
        self.floor_measurement_map = {}
        self.pressure_diff_tolerance = 0.
        self.redundant_measurement_count = 1
        self.filter_window_size = 5
        with open(config_file_path, 'r') as config_file:
            config = yaml.load(config_file)
            for floor_data in config['floor_measurements']:
                self.floor_measurement_map[floor_data['floor_number']] = floor_data['mean_pressure_diff']
            self.reference_floor = config['reference_floor']
            self.pressure_diff_tolerance = config['pressure_diff_tolerance']
            self.redundant_measurement_count = config['redundant_measurement_count']
            self.filter_window_size = config['filter_window_size']

        self.floor_detector = None
        self.floor_setting_sub = None
        self.sw_measurement_sub = None
        self.floor_detection_server = None

    def init(self):
        print('[floor_detector] Initialising floor detection')
        self.floor_detector = FloorDetector(self.reference_floor,
                                            self.floor_measurement_map,
                                            self.pressure_diff_tolerance,
                                            self.redundant_measurement_count,
                                            self.filter_window_size)

        print('[floor_detector] Creating a "{0}" topic subscriber'.format(self.set_floor_topic))
        self.floor_setting_sub = rospy.Subscriber(self.set_floor_topic, Int32,
                                                  self.set_floor_cb)

        print('[floor_detector] Creating a "{0}" topic subscriber'.format(self.sw_data_topic))
        self.sw_measurement_sub = rospy.Subscriber(self.sw_data_topic, SmartWheelData,
                                                   self.register_measurement_cb)

        print('[floor_detector] Advertising a "{0}" server'.format(self.server_name))
        self.floor_detection_server = rospy.Service(self.server_name, DetectFloor,
                                                    self.determine_floor_cb)

        print('[floor_detector] Initialisation completed')
        return FTSMTransitions.INITIALISED

    def running(self):
        status_transition = self.process_depend_statuses()
        if status_transition:
            return status_transition

        return FTSMTransitions.CONTINUE

    def recovering(self):
        sw_data_available = self.depend_statuses[DependMonitorTypes.HEARTBEAT]\
                                                ['smart_wheel']['ros/ros_node_monitor']\
                                                ['sw_ethercat_parser']
        rospy.loginfo('[floor_detector] Waiting for sw_ethercat_parser to become available')
        # TODO: propagate the failure so that the ethercat parser can be (re)started
        while not sw_data_available:
            sw_data_available = self.depend_statuses[DependMonitorTypes.HEARTBEAT]\
                                                    ['smart_wheel']['ros/ros_node_monitor']\
                                                    ['sw_ethercat_parser']
            rospy.sleep(0.5)
        return FTSMTransitions.DONE_RECOVERING

    def process_depend_statuses(self):
        '''Returns FTSMTransitions.RECOVER if the smart wheel ethercat parser
        is unavailable; returns None otherwise.
        '''
        sw_data_available = self.depend_statuses[DependMonitorTypes.HEARTBEAT]\
                                                ['smart_wheel']['ros/ros_node_monitor']\
                                                ['sw_ethercat_parser']
        if not sw_data_available:
            rospy.logwarn('[floor_detector] sw_ethercat_parser not available; trying to recover')
            return FTSMTransitions.RECOVER

        pressure_statuses = self.depend_statuses[DependMonitorTypes.FUNCTIONAL]['pressure']\
                                                ['pressure/pressure_functional_monitor']
        sorted_status_names = sorted([x for x in pressure_statuses.keys()
                                      if 'pressure' in x.lower()])
        pressure_sensor_statuses = [pressure_statuses[x] for x in sorted_status_names]
        self.floor_detector.update_sensor_statuses(pressure_sensor_statuses)

    def set_floor_cb(self, floor_data):
        '''Initialises the current floor of the floor detector with the given data.

        Keyword arguments:
        floor_data: std_msgs.msg.Int32 -- current floor data

        '''
        self.floor_detector.set_current_floor(floor_data.data)

    def register_measurement_cb(self, sw_data):
        '''Saves the pressure measurements from given smart wheel data.

        Keyword arguments:
        sw_data: ropod_ros_msgs.msg.SmartWheelData -- smart wheel data message
        '''
        pressure_measurements = []
        for sensor_data in sw_data.sensors:
            pressure_measurements.append(sensor_data.pressure)
        self.floor_detector.register_measurements(pressure_measurements)

    def determine_floor_cb(self, request):
        '''Responds to request for the current floor.
        Returns a floor_detection.srv.DetectFloorResponse object
        with the current floor estimate.

        If the component is not in a running state, returns a default response (zero floor).

        Keyword arguments: floor_detection.srv.DetectFloorRequest -- service request data

        '''
        response = DetectFloorResponse()
        if self.current_state == FTSMStates.RUNNING:
            current_floor = self.floor_detector.determine_floor()
            response.floor = current_floor
        else:
            rospy.logwarn('[floor_detector] Component not in a running state; ignoring request')
        return response

if __name__ == '__main__':
    rospy.init_node('floor_detection')
    floor_detection_node = FloorDetectionNode()
    try:
        floor_detection_node.run()
        while floor_detection_node.is_running and not rospy.is_shutdown():
            rospy.sleep(0.1)
    except (KeyboardInterrupt, SystemExit):
        print('{0} interrupted; exiting...'.format(floor_detection_node.name))
        floor_detection_node.stop()
